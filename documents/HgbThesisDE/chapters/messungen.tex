\chapter{Messungen}
\label{cha:Messungen}
    In Rahmen dieser Arbeit wurden verschiedene Messungen und Benchmarks der Laufzeit durchgeführt um Vergleiche zwischen den bereits bekannten Technologien und den Neuerungen in Projekt Loom 
    durchführen zu können. 

\section{Testumgebung}                                         
\label{sec:Testumgebung}

    Alle getesteten Programmen wurden mittels Java Development Kit (JDK) \emph{Eclipse Temurin 22.0.2} kompiliert und ausgeführt. Als JVM-Optionenen wurde 
\begin{verbatim}
--add-exports java.management/sun.management=ALL-UNNAMED 
--add-exports jdk.management/com.sun.management.internal=ALL-UNNAMED 
-XX:+UnlockDiagnosticVMOptions -XX:+DebugNonSafepoints\end{verbatim}
    benutzt.
    Das System nutzt Windows 11 Professional als Betriebssystem und ist mit einem "AMD Ryzen 7 7700x" Prozessor ausgestattet. Dabei handelt es sich um eine CPU mit x86-64-Anweisungssatz und 8 
    Kernen mit einer Taktfrequenz zwischen 4,5 und 5,4 GHz. Als Arbeitsspeicher kamen  32 GB DDR5-RAM zum Einsatz die auf 6400MHz takten. Die integrierte Graphikeinheit der CPU wurde der CPU wurde 
    ,um eine zusätzliche Wärmebelastung zu vermeiden, deaktiviert. 
    Für die Laufzeitmessungen wurde das "Java Microbenchmark Harness (JMH)" Version 1.37 verwendet. 


\section{Laufzeitmessungen bei Threads in verschiedenen Szenarien}                                         
\label{sec:LaufzeitmessungenbeiThreadsinverschiedenenSzenarien}

    Um die Stärken und Schwächen von \Glspl{vt} im Vergleich zu \Glspl{pt} genauer ermitteln bzw. evaluieren zu können sind Laufzeitmessungen in verschiedenen Szenarien nötig. 
    Anhand dieser Messungen kann ein Leitfaden für die Auswahl des Threadtypen erstellt werden. 
    Folgende Szenarien werden Behandelt:
    \begin{itemize}
        \item Laufzeitmessungen unter hoher Auslastung
        \item Laufzeitmessungen bei sehr vielen Threads und blockierenden (wartenden) Aufgaben.
        \item Laufzeitmessungen bei einer Abhängigkeit zwischen Threads und Verwendung einer geteilten Ressource.
    \end{itemize}


\subsection{Laufzeitmessungen bei Threads unter hoher Auslastung}                                         
\label{subsec:LaufzeitmessungenbeiThreadsunterhoherAuslastung}

    Ziel des der ersten Laufzeitmessung war es herauszufinden wie sich \Glspl{vt} unter ständiger hoher Auslastung schlagen. Die vom Thread ausgeführte Aufagbe greift aus keine 
    externen Ressourcen wie z.B. Behälter zu und weist auch keine Abhängigkeiten auf andere Prozesse auf. Die Berechnungen sind daher ohne Unterbrechung durchführbar.
    Dieser Vergleich sollte dadurch keine der von den Entwicklern erwähnten  Stärken von \Glspl{vt} nutzen.
    \begin{program} [H]
        \caption{Benchmark eines \Glspl{vt} unter hoher Auslastung}
        \label{prog:BenchmarkEinesVTUnterHoherAuslastung}
    \begin{JavaCode}[language=Java, numbers=left]
@State(Scope.Benchmark)
public class PerformanceVirtual {

    @Param("10000")
    public int nonsenseIterations;

    @Benchmark
    @BenchmarkMode(Mode.SampleTime)
    @OutputTimeUnit(TimeUnit.MILLISECONDS)
    public void testMethodeVirtual() throws InterruptedException {
        Thread.startVirtualThread(() -> {
            for (int i = 0; i < nonsenseIterations; i++)
                Utility.executeNonesense();
        }).join();
    }
}\end{JavaCode}
    \end{program}
    Dieser Benchmark startet einen \gls{vt} und lässt ihm durchgängige rechenintensive Aufgaben erledigen. Um eine Messung durchführen zu können wartet der Eltern-Thread auf
    die Beendung der Aufgaben. Um den Unterschied in der Laufzeit sichtbarer zu gestalten und die Auswirkungen externener Störungsfaktoren zu minimieren 
    wird die Berechnung wiederholt Ausgeführt. Die Anzahl der Ausführungen ist in Zeile 4 definiert. Der Methodenaufruf \texttt{executeNonesense()} in Zeile 13 stellt die Berechnung dar.
    Die Methode wird in \ref{prog:ExecuteNoneSense} näher erklärt. Der Benchmark für die \gls{pt} ist bis auf die Art des Verwendeten Threads ident.
    Als Ergebnis wird die gesamte Dauer der Ausführung geliefert. 

    Die Methode \texttt{executeNonesense} in \ref{prog:ExecuteNoneSense} errechnet alle Primzahlen zwischen 0 und einer in Zeile 2 definierten Obergrenze. Anschließend wird 
    auch noch die Anzahl der Primzahlen ermittelt. Das Ergebnis ist komplett irrelevant und wird nach der Berechnung nicht weiterverwendet. Wichtig ist nur dass es sich um
    eine aufwendige Berechnung handelt.

    \begin{program} [H]
        \caption{Rechenintensive Prozedur}
        \label{prog:ExecuteNoneSense}
    \begin{JavaCode}[language=Java, numbers=left]
public static void executeNonesense() {
    int limit = 100000; // Adjust this limit for more or less intensity
    boolean[] isPrime = new boolean[limit + 1];
    for (int i = 2; i <= limit; i++) 
        isPrime[i] = true;
    for (int factor = 2; factor * factor <= limit; factor++) {
        if (isPrime[factor]) {
            for (int j = factor; factor * j <= limit; j++) 
                isPrime[factor * j] = false;
        }
    }
    int primeCount = 0;
    for (int i = 2; i <= limit; i++) {
        if (isPrime[i])
            primeCount++;
    }
}\end{JavaCode}
    \end{program}

    \emph{\textbf{\textcolor{red}{// TODO: Ergebnis + Erklärung}}}

\subsection{Laufzeitmessungen bei wartenden Auslastung}                                         
\label{subsec:LaufzeitmessungenbeiwartendenAuslastung}

    Der nächste Benchmark behandelt einen Fall bei dem viele sehr wenig rechenintensive Aufgaben parallel gestartet werden. Die Aufgaben selbst simulieren eine wartenden Prozess wie beispielsweise das
    Warten auf die Antwort eines Servers. Die einzelnen Threads werden mittels Executor-Services erstellt. Gegenübergestellt werden ein \texttt{VirtualThreadPerTaskExecutor}, ein \texttt{CachedThreadPool}
    und ein \texttt{ThreadPerTaskExecutor} für \Glspl{pt}. Jeder Thread führt dann ein \texttt{Thread.sleep()} aus und gibt anschließend ein Ergebnis zurück. 


    \emph{\textbf{\textcolor{red}{// TODO: Ergebnis + Erklärung}}}

\subsection{Laufzeitmessungen bei Abhängigkeiten zwischen Threads}
\label{subsec:LaufzeitmessungenbeiAbhängigkeitenzwischenThreads}

    Solch reine Anwendungsfälle wie in den ersten beiden Benchmarks behandelt wurden kommen eher selten vor. Viel häufiger treten Mischfälle auf in denen zwar teils rechenintensive Anweisungen ausgeführt werden
    aber zusätzlich noch externe Abhängigkeiten eine Blockierung des Prozesses bewirken. Aus diesem Grund wird für einen weiteren Laufzeittest ein Produzenten-Konsumenten Modell herangezogen. 